{"version":3,"sources":["demo/src/catalog/technologies/overview/data_flow_digraph.cljs"],"mappings":";AAKA,iEAAA,jEAAOA;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,6EAAA,oCAAA,sHAAA,3gBACGC,weAECC;;AAoBJ,mEAAA,nEAAOC;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,6EAAA,0BAAA,sHAAA,jgBACGF,8dAECC;;AA4BJ,6EAAA,7EAAOE;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,6EAAA,4BAAA,sHAAA,ngBACGH,geAECC;;AA4BJ,uEAAA,vEAAOG;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,iDAAA,8BAAA,sHAAA,zeACGJ,scAECC;;AAkBJ,qEAAA,rEAAOI;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,iDAAA,kBAAA,mFAAA,qDAAA,mFAAA,gDAAA,iCAAA,sHAAA,zwBACGL,suBAECC;;AAiCJ,sEAAA,tEAAOK;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,iDAAA,qBAAA,sHAAA,heACGN,6bAECC;;AAsCJ,iEAAA,jEAAOM;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,iDAAA,gBAAA,sHAAA,3dACGP,wbAECC;;AAaJ,wEAAA,xEAAOO;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,iDAAA,uBAAA,sHAAA,leACGR,+bAECC;;AAIJ,wEAAA,xEAAOQ;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,6EAAA,wCAAA,sHAAA,ouCAAA,gKAAA,8JAAA,+JAAA,0JAAA,12EACGT,4eAECC,01CAgBAG,gKAEAC,8JAEAC,+JAEAC,0JAEAC;;AASJ,yEAAA,zEAAOE;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,6EAAA,iCAAA,sHAAA,xgBACGV,qeAECC;;AAoBJ,4EAAA,5EAAOU;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,6EAAA,mCAAA,sHAAA,1gBACGX,ueAECC;;AAaJ,uEAAA,vEAAOW;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,6EAAA,gDAAA,sHAAA,vhBACGZ,ofAECC;;AAYJ,4EAAA,5EAAOY;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,6EAAA,2BAAA,sHAAA,lgBACGb,+dAECC;;AASJ,gFAAA,hFAAOa;AAAP,AAAA,oHAAA,2CAAA,uEAAA,qEAAA,mFAAA,6EAAA,+BAAA,sHAAA,tgBACGd,meAECC;;AAoBJ,gEAAA,hEAAMc;AAAN,AAAA,mHAAA,2CAAA,uEAAA,qEAAA,oFAAA,qEAAA,0JAAA,4JAAA,sKAAA,iKAAA,iKAAA,kKAAA,qKAAA,gKAAA,qKAAA,nxDACGC,4bAEEjB,0JAEAG,4JAEAC,sKAEAM,iKAEAQ,iKAEAP,kKAEAC,qKAEAC,gKAEAC,qKAEAC","names":["demo.src.catalog.technologies.overview.data-flow-digraph/intro","woolybear.ad.layout/frame","woolybear.ad.layout/markdown-block","demo.src.catalog.technologies.overview.data-flow-digraph/history","demo.src.catalog.technologies.overview.data-flow-digraph/transforming-data","demo.src.catalog.technologies.overview.data-flow-digraph/dev-process","demo.src.catalog.technologies.overview.data-flow-digraph/ui-design","demo.src.catalog.technologies.overview.data-flow-digraph/components","demo.src.catalog.technologies.overview.data-flow-digraph/links","demo.src.catalog.technologies.overview.data-flow-digraph/more-details","demo.src.catalog.technologies.overview.data-flow-digraph/data-flow-ui","demo.src.catalog.technologies.overview.data-flow-digraph/microservices","demo.src.catalog.technologies.overview.data-flow-digraph/other-approaches","demo.src.catalog.technologies.overview.data-flow-digraph/differences","demo.src.catalog.technologies.overview.data-flow-digraph/additional-links","demo.src.catalog.technologies.overview.data-flow-digraph/reactive-programming","demo.src.catalog.technologies.overview.data-flow-digraph/page","woolybear.ad.layout/page","demo.src.catalog.technologies.overview.data-flow.ui-tutorial/tutorial"],"sourcesContent":["(ns demo.src.catalog.technologies.overview.data-flow-digraph\n  (:require [woolybear.ad.layout :as layout]\n            [demo.src.catalog.technologies.overview.data-flow.ui-tutorial :as tutorial]))\n\n\n(defn- intro []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h2.has-text-info \"Data-flow Oriented Design\"]\n   [layout/markdown-block\n    \"> _a system design approach where data is transformed across a collection of 'processes',\n> sometimes called 'automata' (nodes) that are connected (edges) via 'channels' (pub/sub, topics,\n> queues, function calls, etc.)_\n\nWe have developed a mental model of software as a directed graph of data transformations. We see this\nmodel as applicable at al levels of system design (requirements, architecture, modularity, deployment)\nand in all aspects of system implementation (front-end, back-end, etc.).\n\nThis model fits perfectly within the idiomatic approach promoted by the Clojure functional programing language\nwe are developing in: transformations of immutable data, glued together into systems. Rich Hickey, creator of Clojure,\nstrongly promotes the use of queue as a system implementation mechanism (see [here](https://www.youtube.com/watch?v=LKtk3HCgTa8) and\n[here](https://www.youtube.com/watch?v=ROor6_NGIWU)) to decouple the elements of computation/transformation.\n\nAs can be seen through a survey of dataflow system approaches, this model is often applied only to the 'services' portion,\noften called the 'back-end', but we have determined that this approach is perfectly amenable to developing User Interfaces\n(UIs), or 'front-ends'. This is a significant shift from how UI development is typically taught and practiced.\n\"]])\n\n\n(defn- history []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h2.has-text-info \"How we got here\"]\n   [layout/markdown-block \"The breakthrough came when we recognized that 'molecules', as introduced by Brad Frost as\n   part of his [Atomic Design](),\nin chemistry classes are physically modeled using balls and sticks, as show in Figure 1.\n\n![Figure 1. Molecule Modeling Kit](/imgs/data-flow/chemical-modeling-kit.jpeg)\n\n_Figure 1. Molecule Modeling Kit_\n\nCombined with Clojure's, and most other functional programming languages', idiomatic approach promoting system composition from\ntransformations of data (using map, :topic/target-filter, and reduce), and the Re-frame notion of the\n[_signal graph_](https://day8.github.io/re-frame/subscriptions/)\nwe saw that by placing the Signal Graph center of the design, rather than being a by product of a more typical approach, we\ncould unlock the power of the directed graph, simplifying both design and implementation.\n\nWe can also implement any and all UIs in a single, standard way, using a single, standard software mechanism, rather than\ncontinually developing one-off, custom UI elements and composed widgets.\n\nThis approach also means we can apply the same System Engineering approach used for the services on the back-end to the\nfront-end as well! In fact, the front-end is not really a separate system as it is typically considered in the ad hoc approach, but\njust one more collection of transformations of data within the boundary of the 'system' as a whole. However, instead of depositing\nthe results of a transformation into a database or a channel, queue, or topic, in the case of the UI, the results are converted into\nHTML and 'deposited' on the User's display!\n\n> ***Note:*** Although we've developed this sophisticated graph-based capability, ad we encourage you to use it,\n> all the UI components are still available for use in developing more 'typical' ad-hoc UIs. The Data-flow approach\n> is build _on top_ of the basic components. Developers get the best of both worlds!\"]])\n\n\n(defn- transforming-data []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h2.has-text-info \"Transforming Data\"]\n   [layout/markdown-block \"Sticking with our chemistry analogy, chemical processes also perform transformations on the molecules, as\nshown in Figure 2.\n\n![Figure 2. Chemical outputs from the combustion of Ethanol_](/imgs/data-flow/combustion-reaction-model.jpeg)\n\n_Figure 2. Chemical outputs from the combustion of Ethanol._\n\nNote the arrow! Even in this simple example we can see the flow.\n\n\n#### Types of transforms:\n\n- filter : select only certain items or just parts of items, based upon some criterion.\n- transform : convert the physical format; e.g., vector of hash-maps to vector of vectors, etc.\n- augment : add data\n- reduce : materialize a view over a collection of items (summation, group-by, etc.)\n\nThe flow can be defined and visualized as a directed graph (digraph)\n\nOne of the keys to designing software using data-flow is to focus on that data at the\nbeginning (the original source) and the end of the flow (typically the UI or the output)\nof a microservice)\"]])\n\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; region ; Designing a UI with Data-flow\n(defn- dev-process []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h3 \"Development Process\"]\n   [layout/markdown-block \"Overall, the approach to developing using this technique is:\n\n1. Identify the original source(s) of data, typically of 'type' `:source/remote`\n2. Identify the UI components (i.e., `:ui/component`) to visualize the data\n3. Determine the transformations from the source data to the visualization, specifically:\n    - filtering\n    - additional _enhancing_ data, sometimes called _mix-ins_\n    - any re-formatting of the data (rearranging fields, changing hash-map keys, etc.)\n4. Connect the various nodes to each other, from sources, through transformations, and into the UI components\n\nOne way to think of this is as a _directed graph_, with the sources at the top and the UI at the bottom;\nthe data flows _down hill_.\n\n![Figure 3. A simplified directed graph of a UI.]()\n\n_Figure 3. A simplified directed graph of a UI._\"]])\n\n\n(defn- ui-design []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h3 \"Designing a UI \" [:span [:i \"Widget\"]]]\n   [layout/markdown-block \"The very simplest example is to take a single source and connect it directly to a UI component without\nany additional processing, so:\n\n![Figure 4a. Simplest possible UI example visualized as a directed graph.](/imgs/data-flow/simplest-digraph-model.png)\n![Figure 4b. A UI can also be visualized as an Event Model.](/imgs/data-flow/simplest-event-model.png)\n\n_Figure 4. Simplest possible UI example visualized as a Directed Graph or as an Event Model._\n\nAs you can see, we have a single `:source/remote`, which we will call `:source/data` and a single UI\ncomponents, which we will call `:ui/table`. By design, we give each element of the model a\nname (`:source/data` and `:ui/table`) so we can refer to them throughout the definition.\n\nIt is also possible to visualize the same UI as an Event Model. As you can see, the Event Model shows the\nUI element, called the 'View' in EM-speak, with the data source at the bottom, represented as line, showing the data as an 'Event',\nhence the Orange color\n\nEach element also has a _type_ which tells the processing logic how to actually implement the required logic.\nOur toolkit provides dozens of pre-built data and UI components, and you can always develop your own.\n\n\nIn Our system, UI element are described like this:\n\n```\n(def ui-definition\n  {:components   {:topic/measurements {:type :source/remote :name :source/measurements}\n                  :ui/bar-chart       {:type :ui/component :name :rechart/bar}}\n\n   :links        {:topic/measurements {:data {:ui/bar-chart :data}}}\n\n   :grid-layout  [{:i :ui/bar-chart :x 0 :y 0 :w 20 :h 11 :static true}]})\n```\"]])\n\n\n(defn- components []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h3 \"Components\"]\n   [layout/markdown-block \"The `:component` section describes the individual building block (think LEGO) that make up the\nworking part of the UI\ndata-flow. These are the things that do the work: draw the UI, compute values, represent data fetched (subscribed really)\nfrom servers, etc.\n\n##### `:ui/component`\n\nidentifies the UI elements that your Users works with to view and interact with data in the system.\n\n##### `:source/remote` and `:source/local`\n\nare components that both represent data available to use\nwithin your system, and the represent the software mechanisms necessary to access and manage\nsuch data.\n\n##### `:source/fn`\n\nis a _function_, literally a function in the source code, that provides any type of\nmanipulation or transformation of the various data items within the system. For example, if you have some data that\nrepresents some organization that you will want to display on a 3D map, your User might like to control the color and perhaps\nshape to draw for each, making it easy to visually distinguish each item. The original data, perhaps the `:source/remote`\nshould ***NOT*** contains this kind of _visual-only_ data, it should be _mixed-in_ just before your user wants to view it. The\nactual enhancement of the original data with the visually-oriented data should happen in a `:source/fn`.\n\nTypically, you'll want to start by defining either the `:ui/components` or the `:source/remote` data elements, since these tend to\ndrive the purpose of the overall UI _widget_. They identify what you User wants to see (`:source/remote`) and how they will be able\nto see it (`:ui/component`).\n\nNext, you might start to wire your remote data to your UI elements (see _Links_). Quickly, you'll find that you need to introduce\nsome `:source/locals` or `:source/fns` (or more likely both) for one of the following reasons:\n\n1. You want to move data from one `:ui/component` to another\n2. You want to add (`assoc`), remove (`filter`), or transform (`map` or `reduce`) some data so it is fit for some other purpose\n\nNow wou can start to _invent_ these components, since they only exist within the scope of the UI _widget_ you are designing.\n\"]])\n\n\n(defn- links []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h3 \"Links\"]\n   [layout/markdown-block \"`:links` describe how the different parts of the _widget_ connect to\nand communicate with each other, turning a picture of\n'blocks' into a directed graph. In the case of the UI, each component can be designed with multiple input and multiple outputs.\n\nThis is further described by metadata stored in a run-time registry.\n\n#### Grid Layout\n\n`:grid-layout` describe how the various bh-uis, the tables, charts, diagrams,\netc. are to be arranged visually on the display. We use a user-customizable graph component (built in ReactJS) for doing\nthe actual presentation on the display.\"]])\n\n\n(defn- more-details []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h3 \"More Details\"]\n   [layout/markdown-block \"The actual software element that implements these component,\nfor example :rechart/bar.\"]])\n\n\n(defn- data-flow-ui []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h2.has-text-info \"Designing a UI with Data-flow\"]\n   [layout/markdown-block \"Since we are working in Clojure, and, on the UI side, using Re-frame, we take advantage of the Signal Graph\nand take advantage of the [Layer 2 'Extractors' and Layer 3 'Materialized Views'](https://day8.github.io/re-frame/subscriptions/#the-four-layers)\nas the primary mechanisms for the various data transformations needed to support the UI.\n\nLayer 2 extractors are used for remote sources (`:source/remote`), while Layer 3 materialized views provide\nthe computational logic to produce the values for use with `:source/local`.\n\nLayer 4, the View Functions, are provided by the various UI Components we have developed. The demo.src.catalog\nshow them and how they can be used, but within the Data-flow implementation, or more 'manually' as part\nof some custom UI.\n\nThe 'magic' is that our implementation build the Layer 3 subscriptions programmatically, based upon the structure of the data\nyou define for the intermediary, what we call a `:source/local`. In those cases where you must perform some custom logic,\nyou also inject a `:source/fn` or 'source function' to produce the data, and the output can then be fed into other Layer 3 or\neven Layer 4 subscriptions, depending upon how you wire everything together in the graph.\"]\n\n   [dev-process]\n\n   [ui-design]\n\n   [components]\n\n   [links]\n\n   [more-details]])\n\n;; endregion\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; region ; Microservices\n\n(defn- microservices []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h2.has-text-info \"Building Microservices\"]\n   [layout/markdown-block \"Microservices (which are based upon [Willa](https://github.com/DaveWM/willa)), look like this:\n\n```\n(def sudoku-service\n  {:entities {:topic/event-in        (assoc rpl-puzzle-topic ::w/entity-type :topic)\n              :stream/solve-puzzle   {::w/entity-type :kstream\n                                      ::w/xform       sudoku-pipeline}\n              :topic/answer-out      (assoc rpl-solution-topic ::w/entity-type :topic)}\n   :workflow [[:topic/event-in :stream/solve-puzzle]\n              [:stream/solve-puzzle :topic/answer-out]]})\n```\n\nIt's easy to see the relative similarities between these two description. Let's look at each part individually.\n\n\"]])\n\n\n;; endregion\n\n\n(defn- other-approaches []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h2.has-text-info \"Other Similar Approaches\"]\n   [layout/markdown-block\n    \"\n- [Event Modeling](https://eventmodeling.org)\n- [Stream processing](https://en.wikipedia.org/wiki/Stream_processing)\n- [Reactive programming](https://en.wikipedia.org/wiki/Reactive_programming)\n- [LabView](https://www.ni.com/getting-started/labview-basics/dataflow)\n- [Power BI](https://en.wikipedia.org/wiki/Microsoft_Power_BI)\n- [Lucid programming language](https://en.wikipedia.org/wiki/Lucid_(programming_language))\n- [Petri Nets](https://en.wikipedia.org/wiki/Petri_net)\n- [React](https://reactjs.org/)\n- [Re-frame](https://day8.github.io/re-frame/re-frame/)\"]])\n\n\n(defn- differences []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h2.has-text-info \"Differences from Dataflow programming\"]\n   [layout/markdown-block\n    \"Dataflow programming (see [here](https://en.wikipedia.org/wiki/Dataflow_programming)), is often implemented (defined?)\nsuch that the processing steps\nexecute as soon as their inputs all become available. In contrast, in our implementation, there are\ncircumstances where the process will trigger when _any_ of the inputs are available (the other inputs are\nassumed to have default values). Our approach assures that transformation updates will be computed whenever\nany of the inputs change.\n\n> Is this really true? Need to do some investigation/experimentation to determine.\n\"]])\n\n\n(defn- additional-links []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h2.has-text-info \"Additional Links\"]\n   [layout/markdown-block\n    \"\n- [Data Flow (Wikipedia)](https://en.wikipedia.org/wiki/Dataflow)\n- [Dataflow programming (Wikipedia)](https://en.wikipedia.org/wiki/Dataflow_programming)\n- [Kahn process network (Wikipedia)](https://en.wikipedia.org/wiki/Kahn_process_networks)\n\n\"]])\n\n\n(defn- reactive-programming []\n  [layout/frame {:extra-classes :is-fluid}\n   [:h2.has-text-info \"Reactive Programming\"]\n   [layout/markdown-block\n    \"Another key part of our approach, and one which tied tightly with our Data-flow approach, is\nto use 'reactive programming' techniques. Specifically, our approach is 'reactive' in the sense that\na change to the inputs automatically triggers a re-computation of the outputs. This is what drives\nour 'data flows _downhill_' analogy for our directed-graph visualization and mental model.\n\nAn easy way to see this in action is to look at what happens behind the scenes in any dataflow-based UI\nthat includes a `:source/remote`.\n\n\nSee also\n\n- [Reactive Programming](https://en.wikipedia.org/wiki/Reactive_programming)\n- [Functional Reactive Programming](https://en.wikipedia.org/wiki/Functional_reactive_programming)\n- [Stream Processing](https://en.wikipedia.org/wiki/Stream_processing)\n\n\"]])\n\n\n\n(defn page []\n  [layout/page {:extra-classes :is-fluid}\n   [:div.is-fluid\n    [intro]\n\n    [history]\n\n    [transforming-data]\n\n    [data-flow-ui]\n\n    [tutorial/tutorial]\n\n    [microservices]\n\n    [other-approaches]\n\n    [differences]\n\n    [additional-links]\n\n    [reactive-programming]]])\n\n\n\n\n\n"]}