{"version":3,"sources":["bh_ui/molecule/composite.cljs"],"mappings":"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","names":["taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","bh-ui.molecule.composite/component-needs","bh-ui.molecule.composite/source-code","bh-ui.molecule.composite/config","full-config","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","bh-ui.molecule.composite/definition-panel","p__61048","map__61050","cljs.core/--destructure-map","cljs.core.get","seq61047","self__4852__auto__","cljs.core/seq","configuration","components","links","layout","p__61051","map__61052","re-com.core/v-box","js/goog.DEBUG","woolybear.ad.containers/v-scroll-pane","woolybear.ad.layout/text-block","bh-ui.molecule.composite/dag-panel","p__61056","map__61057","seq61054","component-id","container-id","ui","flow","reagent.core.atom","bh-ui.molecule.composite.util.ui/make-flow","node-types","cljs.core.partial","bh-ui.molecule.composite.util.ui/custom-node","minimap-styles","bh-ui.atom.diagram.diagram.composite-dag-support/custom-minimap-node-color","bh-ui.atom.diagram.diagram.composite-dag-support/default-color-pallet","bh-ui.atom.diagram.editable-digraph/color-white","bh-ui.atom.diagram.editable-digraph/color-black","bh-ui.atom.diagram.editable-digraph/component","bh-ui.atom.diagram.diagram.composite-dag-support/default-tool-types"],"sourcesContent":["(ns bh-ui.molecule.composite\n  ; TODO: we can refactor all function into grid-widget\n  \"provides a 'container' to hold and organize other atoms and molecules\ncomponents have 'ports' which define their inputs and outputs:\n\n    you SUBSCRIBE with a :port/sink, ie, data come IN   (rf/subscribe ...)\n\n    you PUBLISH to a :port/source, ie, data goes OUT    (rf/dispatch ...)\n\n    you do BOTH with :port/source-sink (both)           should we even have this, or should we spell out both directions?\n\nthe question about :port/source-sink arises because building the layout (the call for the UI itself) doesn't actually\nneed to make a distinction (in fact the code is a bit cleaner if we don't) and we have the callee sort it out (since it\nneeds to implement the correct usage anyway). The flow-diagram, on the other hand, is easier if we DO make the\ndistinction, so we can quickly build all the Nodes and Handles used for the diagram...\n\"\n  (:require [bh-ui.atom.bhui.table :as bhui-table]\n            [bh-ui.atom.diagram.editable-digraph :as digraph]\n            [bh-ui.atom.diagram.diagram.composite-dag-support :as dag-support]\n            [bh-ui.atom.experimental.ui-element :as e]\n            [bh-ui.atom.re-com.label :as rc-label]\n            [bh-ui.atom.re-com.slider :as rc-slider]\n            [bh-ui.atom.re-com.table :as rc-table]\n            [bh-ui.atom.resium.globe :as r-globe]\n            [bh-ui.atom.worldwind.globe :as ww-globe]\n            [bh-ui.atom.leaflet.globe :as l-globe]\n            [bh-ui.molecule.composite.util.digraph :as dig]\n            [bh-ui.molecule.composite.util.signals :as sig]\n            [bh-ui.molecule.composite.util.ui :as ui]\n            [bh-ui.utils :as ui-utils]\n            [bh-ui.atom.chart.bar-chart :as bar-chart]\n            [bh-ui.atom.chart.area-chart :as area-chart]\n            [bh-ui.atom.chart.colored-pie-chart :as colored-pie-chart]\n            [bh-ui.atom.chart.line-chart :as line-chart]\n            [bh-ui.atom.component-registry :as registry]\n            [day8.re-frame.tracing :refer-macros [fn-traced]]\n            [loom.graph :as lg]\n            [re-com.core :as rc]\n            [re-frame.core :as rf]\n            [reagent.core :as r]\n            [taoensso.timbre :as log]\n            [woolybear.ad.containers :as containers]\n            [woolybear.ad.layout :as layout]))\n\n\n(log/info \"bh-ui.molecule.composite\")\n\n\n(def component-needs {:ui/component  {:name :id}\n                      :source/remote {:name :id}\n                      :source/local  {:name :id :default {:choices #{\"\" 0 [] {} #{}}}}\n                      :source/fn     {:name  :id\n                                      :ports {:name :id\n                                              :type #{:port/source :port/sink :port/source-sink}}}})\n\n\n(def source-code '[composite\n                   :data component/ui-definition\n                   :component-id :container.component\n                   :container-id :container])\n\n\n(defn config [full-config]\n  {:blackboard {:defs {:source full-config\n                       :dag    {:open-details \"\"}}}\n   :container  \"\"})\n\n\n(defn definition-panel\n  \"show the text definition of the composed UI\n  \"\n  [& {:keys [configuration]}]\n\n  (let [components (:components configuration)\n        links      (:links configuration)\n        layout     (:grid-layout configuration)]\n\n    ;(log/info \"definition-panel\" components)\n    ;(log/info \"definition-panel\" links)\n    ;(log/info \"definition-panel\" layout)\n\n    (fn [& {:keys [configuration]}]\n      [rc/v-box :src (rc/at)\n       :width \"70%\"\n       ;:height \"100%\"\n       :gap \"10px\"\n       :children [[:h3 \"Components\"]\n                  [containers/v-scroll-pane {:height \"10em\"}\n                   [layout/text-block (str components)]]\n\n                  [:h3 \"Links\"]\n                  [containers/v-scroll-pane {:height \"10em\"}\n                   [layout/text-block (str links)]]\n\n                  [:h3 \"Layout\"]\n                  [containers/v-scroll-pane {:height \"10em\"}\n                   [layout/text-block (str layout)]]]])))\n\n\n(defn dag-panel\n  \"show the DAG, built form the configuration passed into the component, in a panel\n  (beside the actual UI)\n  \"\n  [& {:keys [configuration component-id container-id ui]}]\n  (let [flow           (r/atom (ui/make-flow configuration))\n        node-types     {\":ui/component\"  (partial ui/custom-node :ui/component)\n                        \":source/remote\" (partial ui/custom-node :source/remote)\n                        \":source/local\"  (partial ui/custom-node :source/local)\n                        \":source/fn\"     (partial ui/custom-node :source/fn)}\n        minimap-styles {:nodeStrokeColor  (partial dag-support/custom-minimap-node-color\n                                            dag-support/default-color-pallet digraph/color-white)\n                        :node-color       (partial dag-support/custom-minimap-node-color\n                                            dag-support/default-color-pallet digraph/color-black)\n                        :nodeBorderRadius 5}]\n\n    [digraph/component\n     :component-id component-id\n     :data flow\n     :node-types node-types\n     :tool-types dag-support/default-tool-types\n     :minimap-styles minimap-styles]))\n\n\n\n\n\n; RICH COMMENTS\n;; region\n\n;; basics of Loom (https://github.com/aysylu/loom)\n(comment\n  (do\n    (def g (lg/graph [1 2] [2 3] {3 [4] 5 [6 7]} 7 8 9))\n    (def dg (lg/digraph g))\n    (def wg (lg/weighted-graph {:a {:b 10 :c 20} :c {:d 30} :e {:b 5 :d 5}}))\n    (def wdg (lg/weighted-digraph [:a :b 10] [:a :c 20] [:c :d 30] [:d :b 10]))\n    (def fg (lg/fly-graph :successors range :weight (constantly 77))))\n\n\n  (lg/nodes g)\n  (lg/edges g)\n  (lg/has-node? g 5)\n  (lg/weighted-graph g)\n\n  (lg/nodes fg)\n\n  ())\n\n\n;; how do we use Loom for our composite?\n(comment\n  (def composite-def {})\n\n  ; a Loom digraph only needs EDGES (:links)\n  (def edges (->> composite-def\n               :links\n               (mapcat (fn [[entity links]]\n                         (map (fn [[target port]]\n                                [entity target])\n                           links)))\n               (into [])))\n\n\n  ; with THIS set of edges, sources and sinks all look like successors\n  (def g (apply lg/digraph edges))\n\n  ())\n\n\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; THIS IS THE ONE!!!\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;\n;; piece together the data needed to build all the UI components and supporting functions\n(comment\n  (do\n    (def config @bh-ui.molecule.composite.coverage-plan/ui-definition)\n    (def container-id \"dummy\")\n    (def links (:links config))\n    (def layout (:layout config))\n    (def components (:components config))\n    (def graph (apply lg/digraph (ui/compute-edges config)))\n    (def nodes (lg/nodes graph))\n    (def edges (lg/edges graph))\n    (def registry @(rf/subscribe [:meta-data-registry]))\n\n    (def configuration (assoc @bh-ui.molecule.composite.coverage-plan/ui-definition\n                         :graph graph\n                         :denorm (dig/denorm-components graph (:links config) (lg/nodes graph))\n                         :nodes (lg/nodes graph)\n                         :edges (lg/edges graph))))\n\n  ;; 1. build the functions... (how? where?)\n  ;; region\n  ;;\n  ;; actually, since the functions \"subscribe\" to some inputs and then produce something\n  ;; that \"others\" subscribe to, they need to be \"cascaded subscriptions\" themselves,\n  ;; so we will actually build the subscriptions alongside step 2, using the data we assemble here\n  ;; (input signals, and the \"subscription name(s)\")\n  ;;\n  ;; NOTE: these functions need to produce ONE subscription for each :port/source\n  ;;\n  ;; for example,\n  ;;\n  ;;         {:fn/compute {:name some-computation\n  ;;                       :ports {:input :port/sink\n  ;;                               :computed-output :port/source}}}\n  ;;\n  ;; builds the equivalent of:\n  ;;\n  ;;         (re/frame/reg-sub-db\n  ;;           :container/blackboard.computed-output\n  ;;           :<- [:container/blackboard.input]\n  ;;           (fn [input [_ _]]\n  ;;              (some-computation* input))\n  ;;\n  ;;;\n  ;; something like,\n  ;;\n  ;;         {:fn/compute {:name some-computation\n  ;;                       :ports {:input-1 :port/sink\n  ;;                               :input-2 :port/sink\n  ;;                               :computed-output :port/source}}}\n  ;;\n  ;; would build the equivalent of:\n  ;;\n  ;;         (re/frame/reg-sub-db\n  ;;           :container/blackboard.computed-output\n  ;;           :<- [:container/blackboard.input-1]\n  ;;           :<- [:container/blackboard.input-2]\n  ;;           (fn [input-1 input-2 [_ _]]\n  ;;              (some-computation* input-1 input-2))\n  ;;\n  ;; endregion\n\n\n  ;; we could mix-in the \"local name\" for each link by mapping over the\n  ;; successors and predecessors\n\n  ;; actually, now it looks like :links already has all the names we need, we just need to\n  ;; make the distinction between :inputs and :outputs for the flow-diagram (the UI Layout doesn't\n  ;; need this data) But, I think we can use this function to split the flow-diagram data from the\n  ;; UI-layout data (and putting BOTH into the expanded data configuration structure)\n\n\n  ;; let's just use the terms :inputs and :outputs and drop the preds/succs\n\n  ;; outputs\n  ;; region\n  (def source :fn/coverage)\n\n  (->> links\n    source\n    (map (fn [[source-port target-meta]]\n           (apply merge\n             (map (fn [[target target-port]]\n                    {target [source-port target-port]})\n               target-meta))))\n    (apply merge))\n\n\n  {:fn/range {:outputs (dig/get-outputs links :fn/range)}}\n  (dig/get-outputs links :fn/coverage)\n\n  ; map over all the components (:ui/globe & :ui/current-time should have not outputs!)\n  (->> nodes\n    (map (fn [node]\n           {node (dig/get-outputs links node)})))\n\n\n  ;; endregion\n\n\n  ;; inputs\n  ;; region\n  (def node :ui/globe)\n\n\n  ; find components with :ui/globe as a target (ie. predecessors of :ui/globe\n  (def preds (lg/predecessors* graph source))\n\n  ; then map over then and pull out their source-port and the target meta-data for\n  ; :ui/globe\n\n  (->> node\n    (lg/predecessors* graph)\n    (map (fn [p]\n           (apply merge\n             (map (fn [[source-port targets]]\n                    (let [target-port (get targets node)]\n                      {p [source-port target-port]}))\n               (get links p)))))\n    (into {}))\n\n  (:topic/coverage-data links)\n\n  (dig/get-inputs links graph :ui/globe)\n  (dig/get-inputs links graph :fn/range)\n\n\n  (->> nodes\n    (map (fn [node]\n           {node (dig/get-inputs links graph node)})))\n\n  ;; endregion\n\n\n  ;; now put is all together\n  ;; region\n\n  (->> nodes\n    (map (fn [node]\n           {node\n            {:inputs  (dig/get-inputs links graph node)\n             :outputs (dig/get-outputs links node)}}))\n    (into {}))\n\n  (dig/denorm-components graph links nodes)\n\n  ;; endregion\n\n  ; GOT IT!\n  ;\n  ; we can now work from any node to its inputs and outputs,\n  ; which means we can build the signal vectors for the ui elements\n  ;\n  ; AND a react-flow diagram of the event-mode for the UI!\n  ;\n\n\n  ; QUESTION: should we mix-in the notion of :local and :remote right here, so we can\n  ; build the correct subscription/event signals?\n  ;\n  ; OR we can leave that logic to the function that actually builds the signal vectors (see\n  ;    Step 2)\n  ;        THIS requires looking at the component's meta-data\n  ;\n  ; OR we could leave it to the component itself to build the correct vector(s)\n  ;\n  ; what about the flow-diagram?\n  ;\n\n\n  ; 2. build the subscription and event signal vectors (just call them)\n  ;; region\n  (defn dummy [& {:keys [data range]}]\n    {:data data :range range})\n\n  (def target :topic/coverage-data)\n  (def thing {:data [:topic/coverage-data], :range [:topic/time-range]})\n\n  (flatten (seq thing))\n\n  (apply conj [:dummy] (flatten (seq thing)))\n\n\n  (->> components\n    (filter (fn [[node meta-data]]\n              (= :ui/component (:type meta-data))))\n    (map (fn [[node meta-data]]\n           (sig/component->ui {:node          node\n                               :type          (:type meta-data)\n                               :configuration configuration\n                               :registry      @(rf/subscribe [:meta-data-registry])\n                               :container-id  :dummy}))))\n\n  ;; endregion\n\n\n  ; the correct order of operations is:\n  ;\n  ; 1. remote subscriptions (including the remote call)\n  ;\n  ; [SIDE EFFECT]\n  (sig/process-components configuration :source/remote @(rf/subscribe [:meta-data-registry]) :coverage-plan)\n\n  ; 1a. build the subscription for the \"container\" which provide the basis for the\n  ;     subscriptions for the \"locals\"\n  ;\n  ; [SIDE EFFECT]\n  (ui-utils/create-container-sub container-id)\n\n\n  ; 2. add blackboard data to the app-db and build local subscriptions/events against the blackboard\n  ;\n  ; [SIDE EFFECT]\n  (sig/process-components configuration :source/local @(rf/subscribe [:meta-data-registry]) :coverage-plan)\n\n  ; 3. local functions (to build subscriptions against the blackboard or remotes)\n  ;\n  ; [SIDE EFFECT]\n  (sig/process-components configuration :source/fn @(rf/subscribe [:meta-data-registry]) :coverage-plan)\n\n  ; 4. build UI components (with subscriptions against the blackboard or remotes)\n  ;\n  ;      actually, this can happen at any time, since evaluation is deferred to Reagent upon re-render\n  ;\n  ; this just builds the vectors and maps them to the component-id in the configuration in pre for Step 5\n  ;\n  (def component-lookup (into {}\n                          (sig/process-components\n                            configuration :ui/component\n                            @(rf/subscribe [:meta-data-registry]) :coverage-plan)))\n\n  ; 5. run layout over the UI components using component-lookup\n  ;\n\n\n\n  ())\n\n\n; get the different handle names, so we can put multiple handles on a single node\n; and then also connect the different edges to the correct one\n(comment\n  (def configuration @bh-ui.molecule.composite.coverage-plan/ui-definition)\n  (def node-id :ui/globe)\n  (def target-id :topic/selected-coverages)\n\n  (or (get-in configuration [:links node-id target-id])\n    (get-in configuration [:links target-id node-id]))\n\n  ())\n\n\n; new logic for building the flow-nodes, so we can have custom node rendering\n(comment\n  (do\n    (def node-id :fn/range)\n    (def graph (apply lg/digraph (ui/compute-edges @bh-ui.molecule.composite.coverage-plan/ui-definition)))\n    (def configuration\n      (assoc @bh-ui.molecule.composite.coverage-plan/ui-definition\n        :graph graph\n        :denorm (dig/denorm-components graph (:links configuration) (lg/nodes graph))\n        :nodes (lg/nodes graph)\n        :edges (lg/edges graph))))\n\n  (:denorm configuration)\n\n  (get-in configuration [:denorm :fn/coverage :inputs])\n\n  (def components (:components configuration))\n\n\n  (map (fn [[node meta-data]]\n         ^{:key node} [:p (str node)])\n    (filter (fn [[node {:keys [type]}]]\n              (= :ui/component type))\n      components))\n\n  (keys components)\n\n\n  ())\n\n\n(comment\n  (do\n    (def data @bh-ui.molecule.composite.coverage-plan/ui-definition)\n    (def graph (apply lg/digraph (ui/compute-edges @bh-ui.molecule.composite.coverage-plan/ui-definition)))\n    (def nodes (lg/nodes graph))\n    (def links (:links data))\n    (def components (:components data))\n    (def configuration (assoc @bh-ui.molecule.composite.coverage-plan/ui-definition\n                         :components (dig/expand-components data @(rf/subscribe [:meta-data-registry]))\n                         :graph graph\n                         :nodes (lg/nodes graph)\n                         :edges (lg/edges graph)))\n\n    (def node-meta (->> links :ui/satellites)))\n\n\n  (->> data\n    :components\n    (map (fn [[id meta-data]]\n           {id (assoc meta-data\n                 :ports\n                 (condp = (:type meta-data)\n                   :ui/component (->> components id :name @(rf/subscribe [:meta-data-registry]) :ports)\n                   :source/remote {:port/pub-sub :data}\n                   :source/local {:port/pub-sub :data}\n                   :source/fn (:ports meta-data)))}))\n    (assoc data :components))\n\n  (dig/expand-components data @(rf/subscribe [:meta-data-registry]))\n\n  (map #(assoc % :ports \"x\") (:components data))\n\n\n  (def target-meta (map (fn [[target _]] (target @(rf/subscribe [:meta-data-registry]))) node-meta))\n\n  (dig/denorm-components graph links nodes)\n\n\n  ())\n\n\n; token substitution\n(comment\n  (do\n    (def config @bh-ui.molecule.composite.coverage-plan/ui-definition)\n    (def container-id \"dummy\")\n    (def links (:links config))\n    (def layout (:layout config))\n    (def components (:components config))\n    (def graph (apply lg/digraph (ui/compute-edges config)))\n    (def nodes (lg/nodes graph))\n    (def edges (lg/edges graph))\n    (def registry @(rf/subscribe [:meta-data-registry]))\n\n    (def configuration (assoc @bh-ui.molecule.composite.coverage-plan/ui-definition\n                         :graph graph\n                         :denorm (dig/denorm-components graph (:links config) (lg/nodes graph))\n                         :nodes (lg/nodes graph)\n                         :edges (lg/edges graph)\n                         :ui-lookup (into {}\n                                      (sig/process-components\n                                        configuration :ui/component\n                                        @(rf/subscribe [:meta-data-registry]) :coverage-plan))))\n    (def component-lookup (into {}\n                            (sig/process-components\n                              configuration :ui/component\n                              @(rf/subscribe [:meta-data-registry]) :coverage-plan)))\n    (def node :h-box))\n\n  (:ui-lookup configuration)\n\n  ;(parse-token component-lookup node)\n\n  ;(into (parse-token lookup node) [:children [:a :b :c]])\n\n\n  ())\n\n\n; subscription scratchpad\n(comment\n  (ui-utils/subscribe-local :coverage-plan-demo.component\n    [:blackboard :topic/current-time])\n\n  (ui-utils/dispatch-local :coverage-plan-demo.component\n    [:blackboard :topic/current-time] (js/Date.))\n\n\n  (rf/reg-sub\n    :coverage-plan-demo.component.blackboard.topic.time-range\n    :<- [:coverage-plan-demo.component.blackboard.topic.current-time]\n    (fn [t _]\n      [0 t]))\n\n\n  (rf/reg-sub\n    :coverage-plan-demo.component.blackboard.topic.layers\n    :<- [:coverage-plan-demo.component.blackboard.topic.selected-targets]\n    :<- [:coverage-plan-demo.component.blackboard.topic.selected-satellites]\n    :<- [:bhui.subs/source :topic/coverage-data]\n    (fn [t s c _]\n      [{:layer-1 {} :layer-2 {}}]))\n\n\n  (ui-utils/dispatch-local :coverage-plan-demo.component\n    [:blackboard :topic/current-time] 75)\n\n\n  (rf/subscribe [:coverage-plan-demo.component.blackboard.topic.current-time])\n  (rf/subscribe [:coverage-plan-demo.component.blackboard.topic.selected-targets])\n  (rf/subscribe [:coverage-plan-demo.component.blackboard.topic.selected-satellites])\n  (rf/subscribe [:bhui.subs/source :source/targets])\n  (rf/subscribe [:bhui.subs/source :source/satellites])\n  (rf/subscribe [:bhui.subs/source :source/coverages])\n\n  (rf/subscribe [:coverage-plan-demo.component.blackboard.topic.layers])\n  (rf/subscribe [:coverage-plan-demo.component.blackboard.topic.time-range])\n\n  ())\n\n\n\n; have to actually CALL the fn/subcription we built!\n(comment\n  (do\n    (def config @bh-ui.molecule.composite.coverage-plan/ui-definition)\n    (def container-id :coverage-plan-demo.component)\n    (def links (:links config))\n    (def layout (:layout config))\n    (def components (:components config))\n    (def graph (apply lg/digraph (dig/compute-edges config)))\n    (def nodes (lg/nodes graph))\n    (def edges (lg/edges graph))\n    (def registry @(rf/subscribe [:meta-data-registry]))\n\n    (def configuration (assoc @bh-ui.molecule.composite.coverage-plan/ui-definition\n                         :graph graph\n                         :denorm (dig/denorm-components graph (:links config) (lg/nodes graph))\n                         :nodes (lg/nodes graph)\n                         :edges (lg/edges graph)\n                         :ui-lookup (into {}\n                                      (sig/process-components\n                                        configuration :ui/component\n                                        @(rf/subscribe [:meta-data-registry]) :coverage-plan))))\n    (def component-lookup (into {}\n                            (sig/process-components\n                              configuration :ui/component\n                              @(rf/subscribe [:meta-data-registry]) :coverage-plan)))\n    (def node :fn/range)\n\n    (def actual-fn (->> configuration :components node :name))\n    (def denorm (->> configuration :denorm node)))\n\n  ())\n\n;; endregion\n\n\n(comment\n  (def components [[[:div \"1\"] [empty] [:div \"2\"]]\n                   [[empty] [:div \"3\"] [:div \"4\"]]])\n  (layout/layout components)\n\n  ())\n\n; make sure the event handler preserves the ordering of the components in the DSL\n(comment\n  (def id \"dummy\")\n  (def c {:containers {id (config id)}})\n\n  ((partial apply conj) [] [[:a :b] [:c :d]])\n\n  ; using DSL (in progress, see component-layout\n  (def components [[[:div \"1\"]]\n                   [[:div \"2\"]]])\n  (def components [[[:div \"1\"] [empty] [:div \"2\"]]\n                   [[:div \"3\"] [:div \"4\"]]])\n\n  (update-in c [:containers id :components] (partial apply conj) components)\n\n  ())\n\n\n(comment\n\n\n\n  ())"]}