{"version":3,"sources":["bh_ui/utils.cljs"],"mappings":"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","names":["bh-ui.utils/default-pub-sub","bh-ui.utils/h-wrap","bh-ui.utils/v-wrap","bh-ui.utils/config-tab-panel","component-id","bh-ui.utils.helpers/config-tab-panel","bh-ui.utils/component-id","bh-ui.utils.helpers/component-id","bh-ui.utils/chart-config","v","data-panel","config-panel","bh-ui.utils.helpers/chart-config","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","bh-ui.utils/path->string","seq51030","self__4852__auto__","cljs.core/seq","path","cljs.core.apply","bh-ui.utils.helpers/path->string","bh-ui.utils/path->keyword","seq51031","bh-ui.utils.helpers/path->keyword","bh-ui.utils/init-container-locals","container-id","locals-and-defaults","bh-ui.utils.locals/init-container-locals","bh-ui.utils/subscribe-local","value-path","bh-ui.utils.locals/subscribe-local","bh-ui.utils/resolve-subscribe-local","bh-ui.utils.locals/resolve-subscribe-local","bh-ui.utils/dispatch-local","new-val","bh-ui.utils.locals/dispatch-local","bh-ui.utils/build-subs","local-config","bh-ui.utils.locals/build-subs","bh-ui.utils/resolve-sub","subs","bh-ui.utils.locals/resolve-sub","bh-ui.utils/init-container","bh-ui.utils.container/init-container","bh-ui.utils/subscribe-to-container","component-path","bh-ui.utils.container/subscribe-to-container","bh-ui.utils/publish-to-container","bh-ui.utils.container/publish-to-container","bh-ui.utils/override-subs","local-subs","bh-ui.utils.container/override-subs","re_frame.core.reg_event_db","day8.re-frame.tracing/is-trace-enabled?","p__51032","vec__51033","cljs.core.nth","+debux-dbg-opts+","day8.re-frame.debux.common.util/send-form!","result__38107__auto__","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","day8.re-frame.debux.common.util/send-trace!","e","e51036","p__51037","vec__51038","db","_","data-source-id","bh-ui.utils/init-data-source","re-frame.core/dispatch","bh-ui.utils/subscribe-data-source","re_frame.core.subscribe","bh_ui.utils.path__GT_keyword"],"sourcesContent":["(ns bh-ui.utils\n  (:require [bh-ui.utils.color :as c]\n            [bh-ui.utils.helpers :as h]\n            [bh-ui.utils.locals :as l]\n            [bh-ui.utils.container :as ctnr]\n            [re-frame.core :as re-frame]\n            [day8.re-frame.tracing :refer-macros [fn-traced]]\n            [taoensso.timbre :as log]))\n\n\n\n\n;;;;;;;;;;;;;\n;\n; helpers\n;\n\n(def default-pub-sub {:pub [] :sub [] :container \"\"})\n\n\n\n\n(def h-wrap {:-webkit-flex-flow \"row wrap\"\n             :flex-flow         \"row wrap\"})\n\n\n(def v-wrap {:-webkit-flex-flow \"column wrap\"\n             :flex-flow         \"column wrap\"})\n\n\n(defn config-tab-panel [component-id]\n  (h/config-tab-panel component-id))\n\n\n(defn component-id []\n  (h/component-id))\n\n\n(defn chart-config [v data-panel config-panel]\n  (h/chart-config v data-panel config-panel))\n\n\n(defn path->string [& path]\n  (apply h/path->string path))\n\n\n(defn path->keyword [& path]\n  (apply h/path->keyword path))\n\n\n;;;;;;;;;;;;;\n;\n; container locals\n;\n\n(defn init-container-locals [container-id locals-and-defaults]\n  (l/init-container-locals container-id locals-and-defaults))\n\n\n(defn subscribe-local [container-id value-path]\n  (l/subscribe-local container-id value-path))\n\n\n(defn resolve-subscribe-local [container-id value-path]\n  (l/resolve-subscribe-local container-id value-path))\n\n\n(defn dispatch-local [container-id value-path new-val]\n  (l/dispatch-local container-id value-path new-val))\n\n\n(defn build-subs [container-id local-config]\n  (l/build-subs container-id local-config))\n\n\n(defn resolve-sub [subs path]\n  (l/resolve-sub subs path))\n\n\n(defn init-container [container-id]\n  (ctnr/init-container container-id))\n\n\n(defn subscribe-to-container [container-id component-path]\n  (ctnr/subscribe-to-container container-id component-path))\n\n\n(defn publish-to-container [container-id component-path new-val]\n  (ctnr/publish-to-container container-id component-path new-val))\n\n\n(defn override-subs [container-id local-subs subs]\n  (ctnr/override-subs container-id local-subs subs))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; Remote DataSource Support\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; region\n\n(re-frame/reg-event-db\n  :events/init-remote-data-source\n  (fn-traced [db [_ data-source-id]]\n    (log/info \":events/init-remote-data-source\" data-source-id)))\n\n\n(defn init-data-source [data-source-id]\n  ;(log/info \":events/init-remote-data-source\" data-source-id)\n  (re-frame/dispatch [:events/init-remote-data-source data-source-id]))\n\n\n(defn subscribe-data-source [data-source-id]\n  ;(log/info \"subscribe-data-source\" data-source-id)\n  (re-frame/subscribe [:data-sources (path->keyword data-source-id)]))\n\n\n\n;; endregion\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; Rich Comments\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; region\n\n; how well does relative-luminance work?\n(comment\n  (do\n    (def black {:r 0 :g 0 :b 0 :a 1.0})\n    (def white {:r 255 :g 255 :b 255 :a 1.0})\n    (def red {:r 255 :g 0 :b 0 :a 1.0})\n    (def green {:r 0 :g 255 :b 0 :a 1.0})\n    (def blue {:r 0 :g 0 :b 255 :a 1.0}))\n\n  (relative-luminance black)\n  (relative-luminance white)\n  (relative-luminance red)\n  (relative-luminance green)\n  (relative-luminance blue)\n\n  ())\n\n\n; how well does best-text-color work?\n(comment\n  (do\n    (def black {:r 0 :g 0 :b 0 :a 1.0})\n    (def white {:r 255 :g 255 :b 255 :a 1.0})\n    (def red {:r 255 :g 0 :b 0 :a 1.0})\n    (def green {:r 0 :g 255 :b 0 :a 1.0})\n    (def blue {:r 0 :g 0 :b 255 :a 1.0}))\n\n  (best-text-color black)\n  (best-text-color white)\n  (best-text-color red)\n  (best-text-color green)\n  (best-text-color blue)\n\n  ())\n\n\n; need to mix the container-id in with the path \"inside\" the container's hash-map\n(comment\n  (def app-db\n    {:containers {:<guid-1>   {:tab-panel  {:value     :<guid-1>/dummy\n                                            :data-path [:<guid-1> :tab-panel]}\n                               :some-value \"value\"\n                               :grid       {:include false}\n                               :x-axis     {:include false}}\n                  :catalog    {:tab-panel {:value     :catalog/atoms\n                                           :data-path [:catalog :tab-panel]}}\n                  :line-chart {:tab-panel {:value     :line-chart/config\n                                           :data-path [:line-chart :tab-panel]}\n                               :grid      {:include true :strokeDasharray {:d 3 :g 3}\n                                           :stroke  \"#ffffff\"}\n                               :x-axis    {:include     true :dataKey \"\"\n                                           :orientation :bottom :scale \"auto\"}\n                               :y-axis    {:include       true :dataKey \"\" :orientation\n                                           :bottom :scale \"auto\"}\n                               :legend    {:include true :layout :horizontal\n                                           :align   :center :verticalAlign :bottom}\n                               :tooltip   {:include true}}}})\n\n\n  (def container-id \"<guid-1>\")\n  (def path [:some-value])\n  (def path [:tab-panel :value])\n\n  (defn subscribe-local [container-id [a & more]]\n    (let [p (path->keyword container-id (str (name a)\n                                          (when more\n                                            (str \".\" (clojure.string/join \".\" (map name more))))))]\n      p))\n  ;(re-frame/subscribe p)))\n\n  (let [d (subscribe-local :line-chart [:grid :strokeDasharray :d])]\n    d)\n  (path->keyword :line-chart)\n\n  (subscribe-local container-id [:some-value])\n  (subscribe-local :line-chart [:tab-panel :value])\n  (subscribe-local :line-chart [:grid :strokeDasharray :d])\n\n  ())\n\n\n; how do we build all the cascading subscriptions for the container's locals?\n; rocky-road just uses a single [containers \"locals\" container-id :some-value]...\n; so it doesn't HAVE cascaded subscriptions in the first place\n(comment\n\n  (def container-locals {:tab-panel  {:value     :<guid-1>/dummy\n                                      :data-path [:<guid-1> :tab-panel]}\n                         :some-value \"value\"\n                         :grid       {}\n                         :x-axis     {}})\n\n  ; NOTE 1: does ':data-path' need the :containers prefix to work? PROBABLY\n\n  ; NOTE 2: container-locals is both the structure AND the initial value\n\n\n  ; THE GOAL:\n  ;\n  ;      (init-container-locals-locals \"container-1\" container-locals)\n  ;\n  ; this (1) builds all the subscriptions AND (2) loads the initial data into the app-db\n  ; at the correct level\n\n\n  ;; region ; set initial values into the app-db:\n  (defn load-local-values [container-id values]\n    (let [target (path->keyword container-id)\n          path   [:events/init-container-locals target values]]\n      (re-frame/dispatch-sync path)))\n\n  (load-local-values \"<guid-1>\" container-locals)\n  (load-local-values \"<guid-2>\" container-locals)\n\n  ;; endregion\n\n  ;; region ; building the subscriptions\n\n  ; let's start with hand-crafted, artisanal subscriptions\n  ; sub-container\n  (re-frame/reg-sub\n    :containers/<guid-1>\n    :<- [:containers]\n    (fn [containers _]\n      (:<guid-1> containers)))\n  @(re-frame/subscribe [:containers])\n  (->> @(re-frame/subscribe [:containers/<guid-1>])\n    keys)\n\n  ; sub-some-value\n  (re-frame/reg-sub\n    :<guid-1>/some-value\n    :<- [:containers/<guid-1>]\n    (fn [containers _]\n      (:some-value containers)))\n  @(re-frame/subscribe [:<guid-1>/some-value])\n\n  ; sub-tab-panel\n  (re-frame/reg-sub\n    :<guid-1>/tab-panel\n    :<- [:containers/<guid-1>]\n    (fn [containers _]\n      (:tab-panel container)))\n  @(re-frame/subscribe [:containers/<guid-1>])\n  @(re-frame/subscribe [:<guid-1>/tab-panel])\n\n  ; sub-tab-panel-value\n  ;    see `subscribe-local` above\n  (re-frame/reg-sub\n    :<guid-1>/tab-panel.value\n    :<- [:<guid-1>/tab-panel]\n    (fn [tab-panel _]\n      (:value tab-panel)))\n  @(re-frame/subscribe [:<guid-1>/tab-panel.value])\n\n  ;; endregion\n\n  ;; region ; subscribing to locals (chart around re-frame/subscribe)\n  (defn subscribe-local [container-id [a & more :as path]]\n    (let [p (path->keyword container-id (str (name a)\n                                          (when more\n                                            (str \".\" (clojure.string/join \".\" (map name more))))))]\n      ;(log/info \"subscribe-local\" container-id path p)\n      (re-frame/subscribe [p])))\n\n  ; let's spell out what we needed to build these subscriptions\n  (def sub-container [\"<guid-1>\"])                             ; [(assume :containers) <container-id>]\n  (def sub-some-value [\"<guid-1>\" [:some-value]])           ; [<container-id> <path>]\n  (def sub-tab-panel [\"<guid-1>\" [:tab-panel]])             ; [container-id> <path>]\n  (def sub-tab-panel-value [\"<guid-1>\" [:tab-panel :value]]) ; [<container-id> <path>]\n\n  ; so 2 types:\n  ;      \"create-container-sub\"        i.e., [<container-id>] (`:widget` is assumed)\n  ;      \"create-container-local-sub\"  i.e., [<container-id> [<path>]]\n\n  (path->keyword :containers \"dummy.part-1.part-2\")\n  (path->keyword :containers \":dummy\")\n  (name :dummy)\n\n  ;; endregion\n\n  ;; region ; create all the subscriptions (by hand)\n  (defn create-container-sub [container-id]\n    (let [id (path->keyword container-id)\n          w  (path->keyword :containers container-id)]\n      (re-frame/reg-sub\n        w\n        :<- [:containers]\n        (fn [containers _]\n          ;(log/info w id)\n          (get containers id)))))\n\n\n  (defn create-container-local-sub [container-id [a & more]]\n    (let [p   (path->keyword container-id (str (name a)\n                                            (when more\n                                              (str \".\" (clojure.string/join \".\" (map name more))))))\n          dep (if more\n                (path->keyword container-id\n                  (str (name a)\n                    (when (seq (drop-last [:value]))\n                      (str \".\" (clojure.string/join \".\" (map name (drop 1 more)))))))\n                (path->keyword :containers container-id))]\n      ;(log/info \"create-container-local-sub\" p dep more (if more (last more) a))\n      (re-frame/reg-sub\n        p\n        :<- [dep]\n        (fn [container _]\n          ;(log/info p dep container (last more))\n          (get container (if more (last more) a))))))\n\n\n  (create-container-sub \"<guid-1>\")\n  @(re-frame/subscribe [:containers/<guid-1>])\n\n  (create-container-local-sub \"<guid-1>\" [:tab-panel])\n  (create-container-local-sub \"<guid-1>\" [:tab-panel :value])\n  (create-container-local-sub \"<guid-1>\" [:tab-panel :data-path])\n  (create-container-local-sub \"<guid-1>\" [:some-value])\n  (create-container-local-sub \"<guid-1>\" [:grid])\n  (create-container-local-sub \"<guid-1>\" [:x-axis])\n\n  @(subscribe-local :<guid-1> [:tab-panel])\n  @(subscribe-local :<guid-1> [:tab-panel :value])\n  @(subscribe-local :<guid-1> [:tab-panel :data-path])\n  @(subscribe-local :<guid-1> [:some-value])\n  @(subscribe-local :<guid-1> [:grid])\n  @(subscribe-local :<guid-1> [:x-axis])\n\n\n  @(re-frame/subscribe [:<guid-1>/tab-panel])\n\n  (create-container-local-sub \"<guid-1>\" [:tab-panel :value])\n  @(subscribe-local :<guid-1> [:tab-panel :value])\n\n  ;; endregion\n\n  ())\n\n\n; now to figure out what subscriptions need to be built for a\n; given container/initial-values-map\n(comment\n  (def container-id \"<guid-1>\")\n\n  ; GOAL:\n  ;\n  ;   (init-container-locals-locals container-id container-locals)\n  ;\n  ; turn container-locals into:\n  ;\n  ;     {\"<guid-1>\" [[:tab-panel]                    => :<guid-1>/tab-panel\n  ;                  [:tab-panel :value]             =>\n  ;                  [:tab-panel :data-path]\n  ;                  [:some-value]\n  ;                  [:grid]\n  ;                  [:grid :include]\n  ;                  [:grid :strokeDasharray]\n  ;                  [:grid :strokeDasharray :dash]  => :<guid-1>/grid.strokeDasharray.dash\n  ;                  [:grid :strokeDasharray :space] => :<guid-1>/grid.strokeDasharray.space\n  ;                  [:x-axis]\n  ;                  [:x-axis :include]\n  ;                  [:set-of-data]}\n  ;\n  ; which can then be processed by\n  ;    (create-container-sub) and (create-container-local-sub)\n  ;\n\n  (def container-locals {:tab-panel   {:value     :<guid-1>/dummy\n                                       :data-path [:<guid-1> :tab-panel]}\n                         :some-value  \"value\"\n                         :grid        {:include         true\n                                       :strokeDasharray {:dash 3 :space 3}}\n                         :x-axis      {:include     true\n                                       :orientation :bottom}\n                         :set-of-data {}})\n\n  (reduce + 0 [1 2 3 4 5])\n\n  (loop [a 0\n         c [1 2 3 4 5]]\n    (if (empty? c)\n      a                                                     ; done!\n      (recur (+ a (first c)) (rest c))))\n\n\n  (defn process-locals [a r t]\n    (println \"process-locals\" a r t)\n    (loop [accum a\n           root  r\n           tree  t]\n      (println \"process\" tree root accum)\n      (if (empty? tree)\n        (do\n          (println \"result\" accum)\n          accum)\n        (let [[k v] (first tree)]\n          (println \"let\" k v)\n          (recur (if (map? v)\n                   (do\n                     (println \"branch\" v (if root\n                                           (if (vector? root)\n                                             (conj root k)\n                                             [root k])\n                                           [k]) accum)\n                     (as-> accum x\n                       ; add this root to the accum\n                       (conj x (if root\n                                 (if (vector? root)\n                                   (conj root k)\n                                   [root k])\n                                 [k]))\n                       ; now process the sub-tree\n                       (apply conj x (process-locals []\n                                       (if root\n                                         (if (vector? root)\n                                           (conj root k)\n                                           [root k])\n                                         k)\n                                       v))))\n                   (do\n                     (println \"leaf\" root k accum)\n                     (conj accum (if root\n                                   (if (vector? root)\n                                     (conj root k)\n                                     [root k])\n                                   [k]))))\n            root\n            (rest tree))))))\n\n  ;; region ; example-based tests\n  (= (process-locals [] nil {:a 1 :b 2})\n    [[:a] [:b]])\n\n  (= (process-locals [] nil {:a 1 :b 2 :c 3})\n    [[:a] [:b] [:c]])\n\n  (= (process-locals [] nil {:a 1 :b {:c 2 :d 3}})\n    [[:a] [:b] [:b :c] [:b :d]])\n\n  (= (process-locals [] nil {:a 1 :b {:c 2} :d {:e 3}})\n    [[:a] [:b] [:d] [:b :c] [:d :e]])\n\n  (= (process-locals [] nil {:a 1 :b {:c 2 :d {:e 3 :f 4}}})\n    [[:a] [:b] [:b :c] [:b :d] [:b :d :e] [:b :d :f]])\n\n  (= (process-locals [] nil {:a 1 :b {:c 2 :d {:e 3 :f {:g [2 4] :h {:i 100}}}}})\n    [[:a] [:b] [:b :c] [:b :d] [:b :d :e] [:b :d :f]\n     [:b :d :f :g] [:b :d :f :h] [:b :d :f :h :i]])\n\n\n  (= (process-locals [] nil container-locals)\n    [[:tab-panel]\n     [:tab-panel :value]\n     [:tab-panel :data-path]\n     [:some-value]\n     [:grid]\n     [:grid :include]\n     [:grid :strokeDasharray]\n     [:grid :strokeDasharray :dash]\n     [:grid :strokeDasharray :space]\n     [:x-axis]\n     [:x-axis :include]\n     [:x-axis :orientation]\n     [:set-of-data]])\n\n  ;; endregion\n\n\n  ())\n\n\n; building the complete set of subscriptions and event-handlers for a 'container'\n; and then testing them out\n(comment\n  (do\n    (def container-id \"<guid-1>\")\n    (def container-locals {:tab-panel   {:selected-panel :<guid-1>/dummy\n                                         :data-path      [:<guid-1> :tab-panel]}\n                           :some-value  \"value\"\n                           :grid        {:include         true\n                                         :strokeDasharray {:dash 3 :space 3}}\n                           :x-axis      {:include     true\n                                         :orientation :bottom}\n                           :set-of-data #{}}))\n\n  (conj [1 2 3] [4 5])\n  (apply conj [1 2 3] [4 5])\n\n  ; set everything up\n  (init-container-locals container-id container-locals)\n\n  ;; region ; try out some subscriptions\n  (= @(subscribe-local container-id [:tab-panel])\n    [])\n  @(subscribe-local container-id [:tab-panel :value])\n  @(subscribe-local container-id [:tab-panel :data-path])\n  @(subscribe-local container-id [:some-value])\n  @(subscribe-local container-id [:grid])\n  @(subscribe-local container-id [:grid :include])\n  @(subscribe-local container-id [:grid :strokeDasharray])\n  @(subscribe-local container-id [:grid :strokeDasharray :dash])\n  @(subscribe-local container-id [:grid :strokeDasharray :space])\n  @(subscribe-local container-id [:x-axis])\n  @(subscribe-local container-id [:x-axis :include])\n  @(subscribe-local container-id [:x-axis :orientation])\n  @(subscribe-local container-id [:set-of-data])\n\n  ;; endregion\n\n  ;; region ; try out the event-handler (user the subscription above to see the updated value)\n  (dispatch-local container-id [:grid :include] true)\n  (dispatch-local container-id [:grid :include] false)\n  (dispatch-local container-id [:grid :strokeDasharray :dash] 5)\n  (dispatch-local container-id [:grid :strokeDasharray :space] 1)\n  (dispatch-local container-id [:set-of-data] #{1 2 3 4 5})\n\n\n\n\n  ;; endregion\n\n\n\n  ())\n\n\n; playing with subscriptions and events\n(comment\n  @(subscribe-local \"line-chart-demo\" [:line-chart-demo/tab-panel.value])\n  (dispatch-local \"line-chart-demo\" [:tab-panel :value] :line-chart-demo/data)\n  (dispatch-local \"line-chart-demo\" [:tab-panel :value] :line-chart-demo/config)\n\n  (re-frame/dispatch [:line-chart-demo/tab-panel.value :line-chart-demo/config])\n  (re-frame/dispatch [:line-chart-demo/tab-panel.value :line-chart-demo/data])\n\n\n  ())\n\n\n; how do we publish things to a \"container\"?\n(comment\n  (do (def db {:containers {:container {:blackboard {}}}})\n      (def container-id :container)\n      (def component-path [:chart-1 :data]))\n\n  (get-in db [:containers container-id :blackboard])\n\n  (-> db\n    (update-in [:containers container-id :blackboard]\n      assoc [:chart-1 :data] \"new-val\")\n    (update-in [:containers container-id :blackboard]\n      assoc [:chart-2 :data] \"another-val\"))\n\n  ())\n\n\n; turning a hash-map into a collection of vectors that are the key paths into all\n; the data leaves\n(comment\n  (def local-config {:brush false,\n                     :uv    {:include true, :stroke \"#8884d8\", :fill \"#8884d8\"},\n                     :pv    {:include true, :stroke \"#ffc107\", :fill \"#ffc107\"},\n                     :tv    {:include true, :stroke \"#82ca9d\", :fill \"#82ca9d\"},\n                     :amt   {:include true, :stroke \"#ff00ff\", :fill \"#ff00ff\"}})\n\n\n  (->> (process-locals [] nil local-config)\n    (map (fn [path]\n           (log/info \"build-container-subs\" container-id path)\n           {path (subscribe-to-container container-id path)}))\n    (into {}))\n\n  (do\n    (def widgcontainer-idet-id \"multi-chart-demo/multi-chart\")\n    (def a :tv)\n    (def more [:fill]))\n\n  (compute-container-path container-id a more)\n\n\n\n\n  ())\n\n\n; building valid keyword for use in the app-db, subscriptions, events, etc\n(comment\n  (def path [\"line-chart-demo\" \"line-chart\" \"tab-panel\" \"value\"])\n  (def path2 '(\"line-chart-demo\" \"line-chart\" [:uv :fill]))\n\n  (keyword (clojure.string/join \".\" path))\n\n  (path->keyword \"line-chart-demo\" \"line-chart\" \"tab-panel\" \"value\")\n\n  (flatten path2)\n  (apply conj [] (flatten path2))\n\n  (->> path2\n    flatten\n    (apply conj [])\n    (map name)\n    (clojure.string/join \".\")\n    keyword)\n\n  (path->keyword \"line-chart-demo\" \"line-chart\" [:uv :fill])\n\n  ())\n\n;; endregion\n\n"]}