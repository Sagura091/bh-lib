"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkDemo"] = self["webpackChunkDemo"] || []).push([["node_modules_astrouxds_astro-web-components_dist_esm_rux-pop-up-menu_entry_js"],{

/***/ "./node_modules/@astrouxds/astro-web-components/dist/esm/rux-pop-up-menu.entry.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@astrouxds/astro-web-components/dist/esm/rux-pop-up-menu.entry.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rux_pop_up_menu: () => (/* binding */ RuxPopUpMenu)\n/* harmony export */ });\n/* harmony import */ var _index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-b64764b4.js */ \"./node_modules/@astrouxds/astro-web-components/dist/esm/index-b64764b4.js\");\n\n\nconst ruxPopUpMenuCss = \":host{display:block;--popup-menu-background-color:var(--color-background-base-default);--popup-menu-border-color:var(--color-border-interactive-muted);--popup-menu-caret-background-color:var(--color-border-interactive-muted);--popup-menu-caret-left:2px;--popup-menu-caret-size:1.875rem;--popup-menu-transition-speed:0.1667s;opacity:0;margin:0;padding:0;position:absolute;pointer-events:none;color:var(--color-background-interactive-default);background-color:var(--popup-menu-border-color);border:1px solid var(--popup-menu-border-color);border-top-width:4px;z-index:10000;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:var(--radius-base);top:-9999rem;left:-9999rem;transition:opacity 0.1667s ease-out;filter:drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5))}:host([hidden]){display:none}:host([open]){pointer-events:auto;opacity:1;transition:opacity 0.1667s ease-in}:host::after{content:\\\"\\\";display:block;position:absolute;z-index:1;border:8px solid transparent;border-bottom:11px solid var(--popup-menu-caret-background-color);left:var(--popup-menu-caret-left, 2px);top:-1.4375rem}ul{position:relative;list-style:none;padding:0;margin:0;background-color:var(--popup-menu-background-color);z-index:2;border-radius:2px}li:last-of-type{border:none;border-radius:0 0 2px 2px}li:first-of-type{border:none;border-radius:2px 2px 0 0}:host(.from-top){border-top-width:1px;border-bottom-width:4px}:host(.from-top)::after{top:unset;bottom:-23px;transform:rotate(180deg)}\";\n\nconst RuxPopUpMenu = class {\n  constructor(hostRef) {\n    (0,_index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);\n    this.ruxMenuWillOpen = (0,_index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, \"ruxmenuwillopen\", 7);\n    this.ruxMenuWillClose = (0,_index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, \"ruxmenuwillclose\", 7);\n    this.ruxMenuDidOpen = (0,_index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, \"ruxmenudidopen\", 7);\n    this.ruxMenuDidClose = (0,_index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, \"ruxmenudidclose\", 7);\n    /**\n     * Boolean which controls when to show the menu\n     */\n    this.open = false;\n  }\n  tieElements() {\n    this._bindElements();\n  }\n  openMenu() {\n    this._toggleOpenClose();\n  }\n  componentDidRender() {\n    if (this.open) {\n      this._setMenuPosition();\n    }\n  }\n  connectedCallback() {\n    this._handleClick = this._handleClick.bind(this);\n    this._handleOutsideClick = this._handleOutsideClick.bind(this);\n    this._bindElements();\n    this._toggleOpenClose();\n  }\n  disconnectedCallback() {\n    if (this.triggerEl) {\n      this.triggerEl.removeEventListener('mousedown', this._handleClick);\n    }\n  }\n  /**\n   * Returns 'true' if the menu is open, 'false' if it is not.\n   */\n  async isOpen() {\n    return this.open;\n  }\n  /**\n   * Opens the menu. If the menu is already open it returns 'false'.\n   */\n  async show() {\n    if (this.open) {\n      return false;\n    }\n    this.open = true;\n    return true;\n  }\n  /**\n   * Closes the menu. If the menu is already closed it returns 'false'.\n   */\n  async close() {\n    if (!this.open) {\n      return false;\n    }\n    this.open = false;\n    return true;\n  }\n  /**\n   * Toggles the menu open or close. Will return 'true' on menu open and 'false' on menu close\n   */\n  async toggle() {\n    this.open = !this.open;\n    return this.open;\n  }\n  handleListen() {\n    this.open = false;\n  }\n  _bindElements() {\n    // find and set triggerEl from aria-controls if not given\n    if (!this.triggerEl) {\n      const triggerEl = document.querySelector(`[aria-controls=\"${this.el.id}\"]`);\n      if (triggerEl) {\n        this.triggerEl = triggerEl;\n        this.triggerEl.addEventListener('mousedown', this._handleClick);\n      }\n    }\n    else {\n      this.triggerEl.addEventListener('mousedown', this._handleClick);\n    }\n    // If a trigger element exists but no anchor, assign trigger to anchor\n    if (!this.anchorEl && this.triggerEl) {\n      this.anchorEl = this.triggerEl;\n      this.anchorBounds = this.anchorEl.getBoundingClientRect();\n    }\n    else if (this.anchorEl) {\n      this.anchorBounds = this.anchorEl.getBoundingClientRect();\n    }\n    this.menuBounds = this.el.getBoundingClientRect();\n  }\n  _setMenuPosition() {\n    if (this.anchorEl && this.anchorBounds && this.menuBounds) {\n      let { anchorBounds, menuBounds } = this;\n      anchorBounds = this.anchorEl.getBoundingClientRect();\n      menuBounds = this.el.getBoundingClientRect();\n      const caret = parseInt(getComputedStyle(this.el, ':after').height);\n      let top;\n      let left;\n      let caretLeft;\n      const padding = 8;\n      // Need to compensate for the amount scrolled horizontally, if present.\n      const scrollX = window.scrollX - padding;\n      if (menuBounds.width + anchorBounds.left - padding >\n        window.innerWidth) {\n        left = anchorBounds.right - menuBounds.width + scrollX;\n        caretLeft = menuBounds.width - 25;\n      }\n      else if (anchorBounds.left - padding > 0) {\n        left = anchorBounds.left - padding;\n        caretLeft = 10;\n      }\n      else {\n        left = padding;\n        caretLeft = 10;\n      }\n      top =\n        anchorBounds.bottom +\n          padding / 2 +\n          19 / 2; /* changed caret ref to 19 for bug fix */\n      if (menuBounds.height + anchorBounds.bottom + padding >\n        window.innerHeight) {\n        top = anchorBounds.top - menuBounds.height - caret;\n        this.el.classList.add('from-top');\n      }\n      else {\n        this.el.classList.remove('from-top');\n      }\n      this.el.style.left = `${left}px`;\n      this.el.style.top = `${top}px`;\n      this.el.style.setProperty('--popup-menu-caret-left', `${caretLeft}px`);\n    }\n  }\n  _handleClick(e) {\n    e.preventDefault();\n    this.open = true;\n  }\n  _handleOutsideClick(e) {\n    const menuClick = e.composedPath().includes(this.el);\n    if (!menuClick) {\n      this.open = false;\n    }\n  }\n  _toggleOpenClose() {\n    var _a, _b;\n    if (this.open) {\n      if (!this.anchorEl) {\n        this.open = false;\n        console.error('Unable to open pop up menu without an anchor element. See documentation');\n        return;\n      }\n      this.ruxMenuWillOpen.emit();\n      const debounce = setTimeout(() => {\n        window.addEventListener('resize', () => this._setMenuPosition());\n        window.addEventListener('mousedown', this._handleOutsideClick);\n        clearTimeout(debounce);\n      }, 10);\n      (_a = this.triggerEl) === null || _a === void 0 ? void 0 : _a.removeEventListener('mousedown', this._handleClick);\n      this.ruxMenuDidOpen.emit();\n    }\n    else {\n      this.ruxMenuWillClose.emit();\n      window.removeEventListener('mousedown', this._handleOutsideClick);\n      window.removeEventListener('resize', this._setMenuPosition);\n      (_b = this.triggerEl) === null || _b === void 0 ? void 0 : _b.addEventListener('mousedown', this._handleClick);\n      this.ruxMenuDidClose.emit();\n    }\n  }\n  render() {\n    return ((0,_index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__.H, { \"aria-hidden\": !this.open ? 'true' : 'false' }, (0,_index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"ul\", { role: \"menu\", \"aria-expanded\": `${this.open}`, part: \"container\" }, (0,_index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"slot\", null)), (0,_index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"slot\", { name: \"menu-end\" })));\n  }\n  get el() { return (0,_index_b64764b4_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }\n  static get watchers() { return {\n    \"triggerEl\": [\"tieElements\"],\n    \"anchorEl\": [\"tieElements\"],\n    \"open\": [\"openMenu\"]\n  }; }\n};\nRuxPopUpMenu.style = ruxPopUpMenuCss;\n\n\n\n\n//# sourceURL=webpack://Demo/./node_modules/@astrouxds/astro-web-components/dist/esm/rux-pop-up-menu.entry.js?");

/***/ })

}]);